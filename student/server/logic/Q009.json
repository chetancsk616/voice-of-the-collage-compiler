{
    "questionId": "Q009",
    "title": "Graph DFS Traversal",
    "difficulty": "Medium",
    "expectedAlgorithm": "Depth-First Search",
    "algorithmDescription": "Traverse graph exploring as far as possible before backtracking",
    "allowedApproaches": [
        "recursive_dfs",
        "stack_based_dfs"
    ],
    "disallowedPatterns": [
        "bfs_traversal",
        "random_traversal"
    ],
    "expectedTimeComplexity": "O(V + E)",
    "expectedSpaceComplexity": "O(V)",
    "paradigm": "Graph Traversal",
    "sampleLanguage": "python",
    "sampleCode": "import sys\nsys.setrecursionlimit(1000000)\n\nv, e = map(int, input().split())\nadj = [[] for _ in range(v)]\nfor _ in range(e):\n    u, w = map(int, input().split())\n    adj[u].append(w)\n    adj[w].append(u)\nstart = int(input())\nfor neighbors in adj:\n    neighbors.sort()\nvisited = [False] * v\norder = []\n\n\ndef dfs(node):\n    visited[node] = True\n    order.append(str(node))\n    for nei in adj[node]:\n        if not visited[nei]:\n            dfs(nei)\n\n\ndfs(start)\nprint(\" \\\".join(order))",
    "expectedCode": "import sys\nsys.setrecursionlimit(1000000)\n\nv, e = map(int, input().split())\nadj = [[] for _ in range(v)]\nfor _ in range(e):\n    u, w = map(int, input().split())\n    adj[u].append(w)\n    adj[w].append(u)\nstart = int(input())\nfor neighbors in adj:\n    neighbors.sort()\nvisited = [False] * v\norder = []\n\n\ndef dfs(node):\n    visited[node] = True\n    order.append(str(node))\n    for nei in adj[node]:\n        if not visited[nei]:\n            dfs(nei)\n\n\ndfs(start)\nprint(\" \\\".join(order))",
    "constraints": {
        "minLineCount": 10,
        "maxLineCount": 40,
        "shouldReadInput": true,
        "shouldUseLoops": true,
        "shouldUseRecursion": true
    },
    "detailedDescription": "Implement Depth-First Search (DFS) for a graph. Input: Number of vertices and edges, followed by edge pairs, then starting vertex. Output: DFS traversal order. DFS explores as far as possible along each branch before backtracking.",
    "hints": [
        "Can use recursion or explicit stack",
        "Mark vertices as visited",
        "Visit vertex, then recursively visit all unvisited neighbors",
        "Use adjacency list representation"
    ],
    "commonMistakes": [
        "Using queue instead of stack/recursion (becomes BFS)",
        "Not maintaining visited set",
        "Incorrect backtracking logic",
        "Wrong graph representation"
    ],
    "solutionApproach": "Build adjacency list. Implement DFS recursively: mark current vertex visited, print it, then recursively call DFS on all unvisited neighbors. Base case: all neighbors visited.",
    "testCaseCriteria": "Must produce valid DFS order (different from BFS). Should handle cycles. Must visit each vertex once.",
    "rubric": {
        "correctOutput": 35,
        "dfsImplementation": 25,
        "visitedTracking": 20,
        "codeClarity": 20
    },
    "testCases": [
        {
            "input": "4 4\n0 1\n0 2\n1 3\n2 3\n0",
            "expectedOutput": "0 1 3 2",
            "description": "Basic DFS from vertex 0 (one valid ordering)"
        },
        {
            "input": "5 4\n0 1\n0 2\n1 3\n2 4\n0",
            "expectedOutput": "0 1 3 2 4",
            "description": "DFS goes deep before backtracking"
        }
    ]
}