{
    "questionId": "Q045",
    "title": "KMP Pattern Matching",
    "difficulty": "Hard",
    "expectedAlgorithm": "KMP Algorithm",
    "algorithmDescription": "Find pattern occurrences in text using Knuth-Morris-Pratt algorithm",
    "allowedApproaches": [
        "kmp_algorithm",
        "lps_array"
    ],
    "disallowedPatterns": [
        "naive_pattern_matching",
        "built_in_find"
    ],
    "expectedTimeComplexity": "O(n + m)",
    "expectedSpaceComplexity": "O(m)",
    "paradigm": "String",
    "constraints": {
        "minLineCount": 20,
        "maxLineCount": 60,
        "shouldReadInput": true,
        "shouldUseLoops": true,
        "shouldUseRecursion": false
    },
    "detailedDescription": "Find all occurrences of pattern in text using KMP algorithm. Input: Text string on first line, pattern on second line. Output: Indices where pattern occurs (space-separated), or -1 if not found. KMP uses LPS (Longest Proper Prefix which is also Suffix) array to avoid redundant comparisons.",
    "hints": [
        "Build LPS array for pattern: tracks longest proper prefix that is also suffix",
        "LPS helps skip already matched characters on mismatch",
        "When mismatch: use LPS to determine next comparison position",
        "No backtracking in text needed"
    ],
    "commonMistakes": [
        "Using naive O(n*m) pattern matching",
        "Incorrect LPS array construction",
        "Not utilizing LPS on mismatch",
        "Using built-in string find function"
    ],
    "solutionApproach": "Build LPS array for pattern. Scan text with two pointers (text and pattern). On match, advance both. On mismatch: if pattern pointer > 0, use LPS to reset pattern pointer; else advance text pointer. Record matches when pattern fully matched.",
    "testCaseCriteria": "Must use KMP algorithm. Should achieve O(n+m) time. Find all occurrences correctly.",
    "rubric": {
        "correctOutput": 30,
        "kmpImplementation": 30,
        "lpsConstruction": 25,
        "codeClarity": 15
    },
    "sampleLanguage": "python",
    "sampleCode": "text = input().strip()\npattern = input().strip()\n\n\ndef build_lps(p):\n    lps = [0] * len(p)\n    length = 0\n    i = 1\n    while i < len(p):\n        if p[i] == p[length]:\n            length += 1\n            lps[i] = length\n            i += 1\n        elif length > 0:\n            length = lps[length - 1]\n        else:\n            lps[i] = 0\n            i += 1\n    return lps\n\n\nif not pattern:\n    print(\"-1\")\nelse:\n    lps = build_lps(pattern)\n    res = []\n    i = j = 0\n    while i < len(text):\n        if text[i] == pattern[j]:\n            i += 1\n            j += 1\n            if j == len(pattern):\n                res.append(str(i - j))\n                j = lps[j - 1]\n        else:\n            if j > 0:\n                j = lps[j - 1]\n            else:\n                i += 1\n    print(\" \\\".join(res) if res else \"-1\")",
    "expectedCode": "text = input().strip()\npattern = input().strip()\n\n\ndef build_lps(p):\n    lps = [0] * len(p)\n    length = 0\n    i = 1\n    while i < len(p):\n        if p[i] == p[length]:\n            length += 1\n            lps[i] = length\n            i += 1\n        elif length > 0:\n            length = lps[length - 1]\n        else:\n            lps[i] = 0\n            i += 1\n    return lps\n\n\nif not pattern:\n    print(\"-1\")\nelse:\n    lps = build_lps(pattern)\n    res = []\n    i = j = 0\n    while i < len(text):\n        if text[i] == pattern[j]:\n            i += 1\n            j += 1\n            if j == len(pattern):\n                res.append(str(i - j))\n                j = lps[j - 1]\n        else:\n            if j > 0:\n                j = lps[j - 1]\n            else:\n                i += 1\n    print(\" \\\".join(res) if res else \"-1\")"
}