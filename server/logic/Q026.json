{
  "questionId": "Q026",
  "title": "Binary Search",
  "difficulty": "Easy",
  "expectedAlgorithm": "Binary Search",
  "algorithmDescription": "Search for target in sorted array using binary search algorithm",
  "allowedApproaches": ["binary_search", "divide_and_conquer_search"],
  "disallowedPatterns": ["linear_search", "sequential_scan"],
  "expectedTimeComplexity": "O(log n)",
  "expectedSpaceComplexity": "O(1)",
  "paradigm": "Binary Search",
  "constraints": {
    "minLineCount": 8,
    "maxLineCount": 30,
    "shouldReadInput": true,
    "shouldUseLoops": true,
    "shouldUseRecursion": false
  },
  "detailedDescription": "Implement binary search to find target element in sorted array. Input: First line has n (array size) and target. Second line has n sorted integers. Output: Index of target (0-based) or -1 if not found. Must achieve O(log n) time complexity.",
  "hints": [
    "Array must be sorted for binary search",
    "Compare target with middle element",
    "If target < middle, search left half; if target > middle, search right half",
    "Use low, high, and mid pointers"
  ],
  "commonMistakes": [
    "Using linear search instead",
    "Incorrect mid calculation causing overflow",
    "Off-by-one errors in boundary updates",
    "Not handling empty array or single element"
  ],
  "solutionApproach": "Initialize low=0, high=n-1. While low <= high: calculate mid=(low+high)/2. If arr[mid]==target, return mid. If arr[mid]<target, low=mid+1. Else high=mid-1. Return -1 if not found.",
  "testCaseCriteria": "Must find target in O(log n) time. Should handle target at boundaries, middle, and not present cases.",
  "rubric": {
    "correctOutput": 40,
    "binarySearchImplementation": 30,
    "timeComplexity": 20,
    "codeClarity": 10
  }
}
