import json
import json
import pathlib


codes = {
    "Q004": """n = int(input())\nprint(\"Even\" if n % 2 == 0 else \"Odd\")""",
    "Q005": """n = int(input())\nresult = 1\nfor i in range(2, n + 1):\n    result *= i\nprint(result)""",
    "Q006": """from collections import deque\n\nclass Node:\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n\n\ndef build_tree(values):\n    if not values:\n        return None\n    root_val = values.popleft()\n    if root_val == -1:\n        return None\n    root = Node(root_val)\n    queue = deque([root])\n    while queue and values:\n        node = queue.popleft()\n        if values:\n            left_val = values.popleft()\n            if left_val != -1:\n                node.left = Node(left_val)\n                queue.append(node.left)\n        if values:\n            right_val = values.popleft()\n            if right_val != -1:\n                node.right = Node(right_val)\n                queue.append(node.right)\n    return root\n\n\ndef height(node):\n    if not node:\n        return -1\n    return 1 + max(height(node.left), height(node.right))\n\n\nn = int(input())\nvals = deque(int(x) for x in input().split())\nroot = build_tree(vals)\nprint(height(root))""",
    "Q007": """from collections import deque\n\nclass Node:\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n\n\ndef build_tree(values):\n    if not values:\n        return None\n    root_val = values.popleft()\n    if root_val == -1:\n        return None\n    root = Node(root_val)\n    queue = deque([root])\n    while queue and values:\n        node = queue.popleft()\n        if values:\n            left_val = values.popleft()\n            if left_val != -1:\n                node.left = Node(left_val)\n                queue.append(node.left)\n        if values:\n            right_val = values.popleft()\n            if right_val != -1:\n                node.right = Node(right_val)\n                queue.append(node.right)\n    return root\n\n\ndef inorder(node, output):\n    if not node:\n        return\n    inorder(node.left, output)\n    output.append(str(node.val))\n    inorder(node.right, output)\n\n\nn = int(input())\nvals = deque(int(x) for x in input().split())\nroot = build_tree(vals)\nresult = []\ninorder(root, result)\nprint(\" \\".join(result))""",
    "Q008": """from collections import deque\n\nv, e = map(int, input().split())\nadj = [[] for _ in range(v)]\nfor _ in range(e):\n    u, w = map(int, input().split())\n    adj[u].append(w)\n    adj[w].append(u)\nstart = int(input())\nfor neighbors in adj:\n    neighbors.sort()\nvisited = [False] * v\norder = []\nqueue = deque([start])\nvisited[start] = True\nwhile queue:\n    node = queue.popleft()\n    order.append(str(node))\n    for nei in adj[node]:\n        if not visited[nei]:\n            visited[nei] = True\n            queue.append(nei)\nprint(\" \\".join(order))""",
    "Q009": """import sys\nsys.setrecursionlimit(1000000)\n\nv, e = map(int, input().split())\nadj = [[] for _ in range(v)]\nfor _ in range(e):\n    u, w = map(int, input().split())\n    adj[u].append(w)\n    adj[w].append(u)\nstart = int(input())\nfor neighbors in adj:\n    neighbors.sort()\nvisited = [False] * v\norder = []\n\n\ndef dfs(node):\n    visited[node] = True\n    order.append(str(node))\n    for nei in adj[node]:\n        if not visited[nei]:\n            dfs(nei)\n\n\ndfs(start)\nprint(\" \\".join(order))""",
    "Q010": """n = int(input())\nif n == 0:\n    print(0)\nelif n == 1:\n    print(1)\nelse:\n    a, b = 0, 1\n    for _ in range(2, n + 1):\n        a, b = b, a + b\n    print(b)""",
    "Q011": """def lcs(a, b):\n    m, n = len(a), len(b)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if a[i - 1] == b[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    return dp[m][n]\n\n\nfirst = input().strip()\nsecond = input().strip()\nprint(lcs(first, second))""",
    "Q012": """class Node:\n    def __init__(self, val):\n        self.val = val\n        self.next = None\n\n\ndef build_list(values):\n    dummy = Node(0)\n    curr = dummy\n    for v in values:\n        curr.next = Node(v)\n        curr = curr.next\n    return dummy.next\n\n\ndef reverse(head):\n    prev = None\n    curr = head\n    while curr:\n        nxt = curr.next\n        curr.next = prev\n        prev = curr\n        curr = nxt\n    return prev\n\n\nn = int(input())\nvals = list(map(int, input().split())) if n > 0 else []\nhead = build_list(vals)\nreversed_head = reverse(head)\noutput = []\nnode = reversed_head\nwhile node:\n    output.append(str(node.val))\n    node = node.next\nprint(\" \\".join(output))""",
    "Q013": """class Node:\n    def __init__(self, val):\n        self.val = val\n        self.next = None\n\n\ndef build_cycle(values, pos):\n    if not values:\n        return None\n    nodes = [Node(v) for v in values]\n    for i in range(len(nodes) - 1):\n        nodes[i].next = nodes[i + 1]\n    if 0 <= pos < len(nodes):\n        nodes[-1].next = nodes[pos]\n    return nodes[0]\n\n\ndef has_cycle(head):\n    slow = fast = head\n    while fast and fast.next:\n        slow = slow.next\n        fast = fast.next.next\n        if slow == fast:\n            return True\n    return False\n\n\nn = int(input())\nvals = list(map(int, input().split())) if n > 0 else []\npos = int(input())\nhead = build_cycle(vals, pos)\nprint(\"true\" if has_cycle(head) else \"false\")""",
    "Q014": """pairs = {')': '(', ']': '[', '}': '{'}\ns = input().strip()\nstack = []\nvalid = True\nfor ch in s:\n    if ch in '([{':\n        stack.append(ch)\n    else:\n        if not stack or stack[-1] != pairs.get(ch):\n            valid = False\n            break\n        stack.pop()\nif stack:\n    valid = False\nprint(\"valid\" if valid else \"invalid\")""",
    "Q015": """n = int(input())\nmain = []\nmins = []\noutputs = []\nfor _ in range(n):\n    parts = input().split()\n    cmd = parts[0]\n    if cmd == \"push\":\n        val = int(parts[1])\n        main.append(val)\n        if not mins or val <= mins[-1]:\n            mins.append(val)\n    elif cmd == \"pop\" and main:\n        val = main.pop()\n        if mins and val == mins[-1]:\n            mins.pop()\n    elif cmd == \"top\":\n        outputs.append(str(main[-1]) if main else \"\")\n    elif cmd == \"getMin\":\n        outputs.append(str(mins[-1]) if mins else \"\")\nprint(\"\n\".join(outputs))""",
    "Q016": """n = int(input())\ninbox = []\noutbox = []\noutputs = []\n\n\ndef move():\n    if not outbox:\n        while inbox:\n            outbox.append(inbox.pop())\n\n\nfor _ in range(n):\n    parts = input().split()\n    cmd = parts[0]\n    if cmd == \"enqueue\":\n        inbox.append(int(parts[1]))\n    elif cmd == \"dequeue\":\n        move()\n        if outbox:\n            outbox.pop()\n    elif cmd == \"front\":\n        move()\n        outputs.append(str(outbox[-1]) if outbox else \"\")\nprint(\"\n\".join(outputs))""",
    "Q017": """k = int(input())\nm = int(input())\nqueue = [0] * k\nfront = 0\nrear = 0\nsize = 0\noutputs = []\n\nfor _ in range(m):\n    parts = input().split()\n    cmd = parts[0]\n    if cmd == \"enqueue\":\n        val = int(parts[1])\n        if size < k:\n            queue[rear] = val\n            rear = (rear + 1) % k\n            size += 1\n    elif cmd == \"dequeue\":\n        if size > 0:\n            front = (front + 1) % k\n            size -= 1\n    elif cmd == \"front\":\n        outputs.append(str(queue[front]) if size > 0 else \"\")\n    elif cmd == \"rear\":\n        outputs.append(str(queue[(rear - 1 + k) % k]) if size > 0 else \"\")\n    elif cmd == \"isEmpty\":\n        outputs.append(\"true\" if size == 0 else \"false\")\n    elif cmd == \"isFull\":\n        outputs.append(\"true\" if size == k else \"false\")\nprint(\"\n\".join(outputs))""",
    "Q018": """import heapq\n\nn, k = map(int, input().split())\nnums = list(map(int, input().split()))\nheap = []\nfor num in nums:\n    heapq.heappush(heap, num)\n    if len(heap) > k:\n        heapq.heappop(heap)\nprint(heap[0])""",
    "Q019": """import heapq\n\nk = int(input())\nlists = []\nfor _ in range(k):\n    line = input().strip()\n    lists.append(list(map(int, line.split())) if line else [])\nheap = []\nfor idx, arr in enumerate(lists):\n    if arr:\n        heapq.heappush(heap, (arr[0], idx, 0))\nresult = []\nwhile heap:\n    val, i, j = heapq.heappop(heap)\n    result.append(str(val))\n    if j + 1 < len(lists[i]):\n        heapq.heappush(heap, (lists[i][j + 1], i, j + 1))\nprint(\" \\".join(result))""",
    "Q020": """def merge(left, right):\n    merged = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            merged.append(left[i])\n            i += 1\n        else:\n            merged.append(right[j])\n            j += 1\n    merged.extend(left[i:])\n    merged.extend(right[j:])\n    return merged\n\n\ndef merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) // 2\n    left = merge_sort(arr[:mid])\n    right = merge_sort(arr[mid:])\n    return merge(left, right)\n\n\nn = int(input())\narr = list(map(int, input().split()))\nprint(\" \\".join(map(str, merge_sort(arr))))""",
    "Q021": """def partition(arr, low, high):\n    pivot = arr[high]\n    i = low\n    for j in range(low, high):\n        if arr[j] <= pivot:\n            arr[i], arr[j] = arr[j], arr[i]\n            i += 1\n    arr[i], arr[high] = arr[high], arr[i]\n    return i\n\n\ndef quick_sort(arr, low, high):\n    if low < high:\n        pi = partition(arr, low, high)\n        quick_sort(arr, low, pi - 1)\n        quick_sort(arr, pi + 1, high)\n\n\nn = int(input())\narr = list(map(int, input().split()))\nquick_sort(arr, 0, len(arr) - 1)\nprint(\" \\".join(map(str, arr)))""",
    "Q022": """n, target = map(int, input().split())\nnums = list(map(int, input().split()))\nseen = {}\nfor i, num in enumerate(nums):\n    comp = target - num\n    if comp in seen:\n        print(seen[comp], i)\n        break\n    seen[num] = i""",
    "Q023": """from collections import defaultdict\n\ngroups = defaultdict(list)\ncount = int(input())\nfor _ in range(count):\n    word = input().strip()\n    key = \"\".join(sorted(word))\n    groups[key].append(word)\nfor group in groups.values():\n    print(\" \\".join(group))""",
    "Q024": """n = int(input())\nnums = list(map(int, input().split()))\nused = [False] * n\nperm = []\noutput = []\n\n\ndef backtrack():\n    if len(perm) == n:\n        output.append(\" \\".join(map(str, perm)))\n        return\n    for i in range(n):\n        if not used[i]:\n            used[i] = True\n            perm.append(nums[i])\n            backtrack()\n            perm.pop()\n            used[i] = False\n\n\nbacktrack()\nprint(\"\n\".join(output))""",
    "Q025": """n = int(input())\ncols = set()\ndiag1 = set()\ndiag2 = set()\nboard = [[\".\"] * n for _ in range(n)]\ncount = [0]\nfirst = []\n\n\ndef backtrack(row):\n    if row == n:\n        count[0] += 1\n        if not first:\n            first.extend(\"\".join(r) for r in board)\n        return\n    for c in range(n):\n        if c in cols or (row - c) in diag1 or (row + c) in diag2:\n            continue\n        cols.add(c)\n        diag1.add(row - c)\n        diag2.add(row + c)\n        board[row][c] = \"Q\"\n        backtrack(row + 1)\n        board[row][c] = \".\"\n        cols.remove(c)\n        diag1.remove(row - c)\n        diag2.remove(row + c)\n\n\nbacktrack(0)\nprint(count[0])\nif first:\n    print(\"\n\".join(first))""",
    "Q026": """n, target = map(int, input().split())\narr = list(map(int, input().split()))\nlow, high = 0, n - 1\nresult = -1\nwhile low <= high:\n    mid = (low + high) // 2\n    if arr[mid] == target:\n        result = mid\n        break\n    if arr[mid] < target:\n        low = mid + 1\n    else:\n        high = mid - 1\nprint(result)""",
    "Q027": """def bound(arr, target, first):\n    low, high = 0, len(arr) - 1\n    res = -1\n    while low <= high:\n        mid = (low + high) // 2\n        if arr[mid] == target:\n            res = mid\n            if first:\n                high = mid - 1\n            else:\n                low = mid + 1\n        elif arr[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return res\n\n\n_, target = map(int, input().split())\narr = list(map(int, input().split()))\nfirst = bound(arr, target, True)\nlast = bound(arr, target, False)\nprint(first, last)""",
    "Q028": """n, k = map(int, input().split())\narr = list(map(int, input().split()))\nif k > n:\n    print(0)\nelse:\n    window = sum(arr[:k])\n    best = window\n    for i in range(k, n):\n        window += arr[i] - arr[i - k]\n        best = max(best, window)\n    print(best)""",
    "Q029": """s = input().strip()\nseen = {}\nleft = 0\nbest = 0\nfor right, ch in enumerate(s):\n    if ch in seen and seen[ch] >= left:\n        left = seen[ch] + 1\n    seen[ch] = right\n    best = max(best, right - left + 1)\nprint(best)""",
    "Q030": """n = int(input())\nheights = list(map(int, input().split()))\nl, r = 0, n - 1\nbest = 0\nwhile l < r:\n    area = min(heights[l], heights[r]) * (r - l)\n    best = max(best, area)\n    if heights[l] < heights[r]:\n        l += 1\n    else:\n        r -= 1\nprint(best)""",
    "Q031": """n = int(input())\nnums = sorted(map(int, input().split()))\ntriplets = []\nfor i in range(n - 2):\n    if i > 0 and nums[i] == nums[i - 1]:\n        continue\n    l, r = i + 1, n - 1\n    while l < r:\n        s = nums[i] + nums[l] + nums[r]\n        if s == 0:\n            triplets.append((nums[i], nums[l], nums[r]))\n            l += 1\n            r -= 1\n            while l < r and nums[l] == nums[l - 1]:\n                l += 1\n            while l < r and nums[r] == nums[r + 1]:\n                r -= 1\n        elif s < 0:\n            l += 1\n        else:\n            r -= 1\nfor a, b, c in triplets:\n    print(f\"{a} {b} {c}\")""",
    "Q032": """class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.end = False\n\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word):\n        node = self.root\n        for ch in word:\n            node = node.children.setdefault(ch, TrieNode())\n        node.end = True\n\n    def search(self, word):\n        node = self.root\n        for ch in word:\n            if ch not in node.children:\n                return False\n            node = node.children[ch]\n        return node.end\n\n    def starts_with(self, prefix):\n        node = self.root\n        for ch in prefix:\n            if ch not in node.children:\n                return False\n            node = node.children[ch]\n        return True\n\n\ntrie = Trie()\noutputs = []\nq = int(input())\nfor _ in range(q):\n    cmd, arg = input().split()\n    if cmd == \"insert\":\n        trie.insert(arg)\n    elif cmd == \"search\":\n        outputs.append(\"true\" if trie.search(arg) else \"false\")\n    elif cmd == \"startsWith\":\n        outputs.append(\"true\" if trie.starts_with(arg) else \"false\")\nprint(\"\n\".join(outputs))""",
    "Q033": """m, n = map(int, input().split())\nboard = [input().split() for _ in range(m)]\nword_count = int(input())\nwords = [input().strip() for _ in range(word_count)]\n\nclass Node:\n    def __init__(self):\n        self.children = {}\n        self.word = None\n\n\nroot = Node()\nfor word in words:\n    node = root\n    for ch in word:\n        node = node.children.setdefault(ch, Node())\n    node.word = word\n\nfound = set()\nvisited = [[False] * n for _ in range(m)]\ndirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n\n\ndef dfs(r, c, node):\n    ch = board[r][c]\n    if ch not in node.children:\n        return\n    nxt = node.children[ch]\n    if nxt.word:\n        found.add(nxt.word)\n    visited[r][c] = True\n    for dr, dc in dirs:\n        nr, nc = r + dr, c + dc\n        if 0 <= nr < m and 0 <= nc < n and not visited[nr][nc]:\n            dfs(nr, nc, nxt)\n    visited[r][c] = False\n\n\nfor i in range(m):\n    for j in range(n):\n        dfs(i, j, root)\nprint(\" \\".join(sorted(found)))""",
    "Q034": """n = int(input())\nactivities = [tuple(map(int, input().split())) for _ in range(n)]\nactivities.sort(key=lambda x: x[1])\ncount = 0\nend_time = -1\nfor start, finish in activities:\n    if start >= end_time:\n        count += 1\n        end_time = finish\nprint(count)""",
    "Q035": """import heapq\n\nsize = int(input())\nfreqs = []\nfor _ in range(size):\n    parts = input().split()\n    freqs.append(int(parts[-1]))\nheapq.heapify(freqs)\ncost = 0\nwhile len(freqs) > 1:\n    a = heapq.heappop(freqs)\n    b = heapq.heappop(freqs)\n    s = a + b\n    cost += s\n    heapq.heappush(freqs, s)\nprint(cost)""",
    "Q036": """n = int(input())\ncount = 0\nwhile n:\n    n &= n - 1\n    count += 1\nprint(count)""",
    "Q037": """n = int(input())\nnums = list(map(int, input().split()))\nresult = 0\nfor num in nums:\n    result ^= num\nprint(result)""",
    "Q038": """n = int(input())\nnums = list(map(int, input().split()))\ncurrent = max_sum = nums[0]\nfor num in nums[1:]:\n    current = max(num, current + num)\n    max_sum = max(max_sum, current)\nprint(max_sum)""",
    "Q039": """def merge_sort(arr):\n    if len(arr) <= 1:\n        return arr, 0\n    mid = len(arr) // 2\n    left, inv_left = merge_sort(arr[:mid])\n    right, inv_right = merge_sort(arr[mid:])\n    merged = []\n    i = j = 0\n    inv_count = inv_left + inv_right\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            merged.append(left[i])\n            i += 1\n        else:\n            merged.append(right[j])\n            j += 1\n            inv_count += len(left) - i\n    merged.extend(left[i:])\n    merged.extend(right[j:])\n    return merged, inv_count\n\n\n_ = int(input())\narr = list(map(int, input().split()))\n_, inversions = merge_sort(arr)\nprint(inversions)""",
    "Q040": """v, e = map(int, input().split())\nparent = list(range(v))\nrank = [0] * v\n\n\ndef find(x):\n    if parent[x] != x:\n        parent[x] = find(parent[x])\n    return parent[x]\n\n\ndef union(a, b):\n    ra, rb = find(a), find(b)\n    if ra == rb:\n        return False\n    if rank[ra] < rank[rb]:\n        parent[ra] = rb\n    elif rank[ra] > rank[rb]:\n        parent[rb] = ra\n    else:\n        parent[rb] = ra\n        rank[ra] += 1\n    return True\n\n\nhas_cycle = False\nfor _ in range(e):\n    u, w = map(int, input().split())\n    if not union(u, w):\n        has_cycle = True\nprint(\"true\" if has_cycle else \"false\")""",
    "Q041": """v, e = map(int, input().split())\nparent = list(range(v))\nrank = [0] * v\ncomponents = [v]\n\n\ndef find(x):\n    if parent[x] != x:\n        parent[x] = find(parent[x])\n    return parent[x]\n\n\ndef union(a, b):\n    ra, rb = find(a), find(b)\n    if ra == rb:\n        return\n    if rank[ra] < rank[rb]:\n        parent[ra] = rb\n    elif rank[ra] > rank[rb]:\n        parent[rb] = ra\n    else:\n        parent[rb] = ra\n        rank[ra] += 1\n    components[0] -= 1\n\n\nfor _ in range(e):\n    u, w = map(int, input().split())\n    union(u, w)\nprint(components[0])""",
    "Q042": """m, n = map(int, input().split())\nmatrix = [list(map(int, input().split())) for _ in range(m)]\ntop, bottom, left, right = 0, m - 1, 0, n - 1\norder = []\nwhile top <= bottom and left <= right:\n    for c in range(left, right + 1):\n        order.append(str(matrix[top][c]))\n    top += 1\n    for r in range(top, bottom + 1):\n        order.append(str(matrix[r][right]))\n    right -= 1\n    if top <= bottom:\n        for c in range(right, left - 1, -1):\n            order.append(str(matrix[bottom][c]))\n        bottom -= 1\n    if left <= right:\n        for r in range(bottom, top - 1, -1):\n            order.append(str(matrix[r][left]))\n        left += 1\nprint(\" \\".join(order))""",
    "Q043": """n = int(input())\nmatrix = [list(map(int, input().split())) for _ in range(n)]\nfor i in range(n):\n    for j in range(i + 1, n):\n        matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\nfor row in matrix:\n    row.reverse()\nfor row in matrix:\n    print(\" \\".join(map(str, row)))""",
    "Q044": """s = input().strip()\nif not s:\n    print(\"\")\nelse:\n    start = end = 0\n\n    def expand(l, r):\n        while l >= 0 and r < len(s) and s[l] == s[r]:\n            l -= 1\n            r += 1\n        return l + 1, r - 1\n\n    for i in range(len(s)):\n        l1, r1 = expand(i, i)\n        if r1 - l1 > end - start:\n            start, end = l1, r1\n        l2, r2 = expand(i, i + 1)\n        if r2 - l2 > end - start:\n            start, end = l2, r2\n    print(s[start:end + 1])""",
    "Q045": """text = input().strip()\npattern = input().strip()\n\n\ndef build_lps(p):\n    lps = [0] * len(p)\n    length = 0\n    i = 1\n    while i < len(p):\n        if p[i] == p[length]:\n            length += 1\n            lps[i] = length\n            i += 1\n        elif length > 0:\n            length = lps[length - 1]\n        else:\n            lps[i] = 0\n            i += 1\n    return lps\n\n\nif not pattern:\n    print(\"-1\")\nelse:\n    lps = build_lps(pattern)\n    res = []\n    i = j = 0\n    while i < len(text):\n        if text[i] == pattern[j]:\n            i += 1\n            j += 1\n            if j == len(pattern):\n                res.append(str(i - j))\n                j = lps[j - 1]\n        else:\n            if j > 0:\n                j = lps[j - 1]\n            else:\n                i += 1\n    print(\" \\".join(res) if res else \"-1\")""",
}

base = pathlib.Path("student/server/logic")
for qid, code in codes.items():
    path = base / f"{qid}.json"
    data = json.loads(path.read_text())
    data["sampleLanguage"] = "python"
    data["sampleCode"] = code
    data["expectedCode"] = code
    path.write_text(json.dumps(data, indent=4))
    "Q021": """def partition(arr, low, high):\n    pivot = arr[high]\n    i = low\n    for j in range(low, high):\n        if arr[j] <= pivot:\n            arr[i], arr[j] = arr[j], arr[i]\n            i += 1\n    arr[i], arr[high] = arr[high], arr[i]\n    return i\n\n\ndef quick_sort(arr, low, high):\n    if low < high:\n        pi = partition(arr, low, high)\n        quick_sort(arr, low, pi - 1)\n        quick_sort(arr, pi + 1, high)\n\n\nn = int(input())\narr = list(map(int, input().split()))\nquick_sort(arr, 0, len(arr) - 1)\nprint(\" \\".join(map(str, arr)))""",
    "Q022": """n, target = map(int, input().split())\nnums = list(map(int, input().split()))\nseen = {}\nfor i, num in enumerate(nums):\n    comp = target - num\n    if comp in seen:\n        print(seen[comp], i)\n        break\n    seen[num] = i""",
    "Q023": """from collections import defaultdict\n\ngroups = defaultdict(list)\ncount = int(input())\nfor _ in range(count):\n    word = input().strip()\n    key = \"\".join(sorted(word))\n    groups[key].append(word)\nfor group in groups.values():\n    print(\" \\".join(group))""",
    "Q024": """n = int(input())\nnums = list(map(int, input().split()))\nused = [False] * n\nperm = []\noutput = []\n\n\ndef backtrack():\n    if len(perm) == n:\n        output.append(\" \\".join(map(str, perm)))\n        return\n    for i in range(n):\n        if not used[i]:\n            used[i] = True\n            perm.append(nums[i])\n            backtrack()\n            perm.pop()\n            used[i] = False\n\n\nbacktrack()\nprint(\"\n\".join(output))""",
    "Q025": """n = int(input())\ncols = set()\ndiag1 = set()\ndiag2 = set()\nboard = [[\".\"] * n for _ in range(n)]\ncount = [0]\nfirst = []\n\n\ndef backtrack(row):\n    if row == n:\n        count[0] += 1\n        if not first:\n            first.extend(\"\".join(r) for r in board)\n        return\n    for c in range(n):\n        if c in cols or (row - c) in diag1 or (row + c) in diag2:\n            continue\n        cols.add(c)\n        diag1.add(row - c)\n        diag2.add(row + c)\n        board[row][c] = \"Q\"\n        backtrack(row + 1)\n        board[row][c] = \".\"\n        cols.remove(c)\n        diag1.remove(row - c)\n        diag2.remove(row + c)\n\n\nbacktrack(0)\nprint(count[0])\nif first:\n    print(\"\n\".join(first))""",
    "Q026": """n, target = map(int, input().split())\narr = list(map(int, input().split()))\nlow, high = 0, n - 1\nresult = -1\nwhile low <= high:\n    mid = (low + high) // 2\n    if arr[mid] == target:\n        result = mid\n        break\n    if arr[mid] < target:\n        low = mid + 1\n    else:\n        high = mid - 1\nprint(result)""",
    "Q027": """def bound(arr, target, first):\n    low, high = 0, len(arr) - 1\n    res = -1\n    while low <= high:\n        mid = (low + high) // 2\n        if arr[mid] == target:\n            res = mid\n            if first:\n                high = mid - 1\n            else:\n                low = mid + 1\n        elif arr[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return res\n\n\n_, target = map(int, input().split())\narr = list(map(int, input().split()))\nfirst = bound(arr, target, True)\nlast = bound(arr, target, False)\nprint(first, last)""",
    "Q028": """n, k = map(int, input().split())\narr = list(map(int, input().split()))\nif k > n:\n    print(0)\nelse:\n    window = sum(arr[:k])\n    best = window\n    for i in range(k, n):\n        window += arr[i] - arr[i - k]\n        best = max(best, window)\n    print(best)""",
    "Q029": """s = input().strip()\nseen = {}\nleft = 0\nbest = 0\nfor right, ch in enumerate(s):\n    if ch in seen and seen[ch] >= left:\n        left = seen[ch] + 1\n    seen[ch] = right\n    best = max(best, right - left + 1)\nprint(best)""",
    "Q030": """n = int(input())\nheights = list(map(int, input().split()))\nl, r = 0, n - 1\nbest = 0\nwhile l < r:\n    area = min(heights[l], heights[r]) * (r - l)\n    best = max(best, area)\n    if heights[l] < heights[r]:\n        l += 1\n    else:\n        r -= 1\nprint(best)""",
    "Q031": """n = int(input())\nnums = sorted(map(int, input().split()))\ntriplets = []\nfor i in range(n - 2):\n    if i > 0 and nums[i] == nums[i - 1]:\n        continue\n    l, r = i + 1, n - 1\n    while l < r:\n        s = nums[i] + nums[l] + nums[r]\n        if s == 0:\n            triplets.append((nums[i], nums[l], nums[r]))\n            l += 1\n            r -= 1\n            while l < r and nums[l] == nums[l - 1]:\n                l += 1\n            while l < r and nums[r] == nums[r + 1]:\n                r -= 1\n        elif s < 0:\n            l += 1\n        else:\n            r -= 1\nfor a, b, c in triplets:\n    print(f\"{a} {b} {c}\")""",
    "Q032": """class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.end = False\n\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word):\n        node = self.root\n        for ch in word:\n            node = node.children.setdefault(ch, TrieNode())\n        node.end = True\n\n    def search(self, word):\n        node = self.root\n        for ch in word:\n            if ch not in node.children:\n                return False\n            node = node.children[ch]\n        return node.end\n\n    def starts_with(self, prefix):\n        node = self.root\n        for ch in prefix:\n            if ch not in node.children:\n                return False\n            node = node.children[ch]\n        return True\n\n\ntrie = Trie()\noutputs = []\nq = int(input())\nfor _ in range(q):\n    cmd, arg = input().split()\n    if cmd == \"insert\":\n        trie.insert(arg)\n    elif cmd == \"search\":\n        outputs.append(\"true\" if trie.search(arg) else \"false\")\n    elif cmd == \"startsWith\":\n        outputs.append(\"true\" if trie.starts_with(arg) else \"false\")\nprint(\"\n\".join(outputs))""",
    "Q033": """m, n = map(int, input().split())\nboard = [input().split() for _ in range(m)]\nword_count = int(input())\nwords = [input().strip() for _ in range(word_count)]\n\nclass Node:\n    def __init__(self):\n        self.children = {}\n        self.word = None\n\n\nroot = Node()\nfor word in words:\n    node = root\n    for ch in word:\n        node = node.children.setdefault(ch, Node())\n    node.word = word\n\nfound = set()\nvisited = [[False] * n for _ in range(m)]\ndirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n\n\ndef dfs(r, c, node):\n    ch = board[r][c]\n    if ch not in node.children:\n        return\n    nxt = node.children[ch]\n    if nxt.word:\n        found.add(nxt.word)\n    visited[r][c] = True\n    for dr, dc in dirs:\n        nr, nc = r + dr, c + dc\n        if 0 <= nr < m and 0 <= nc < n and not visited[nr][nc]:\n            dfs(nr, nc, nxt)\n    visited[r][c] = False\n\n\nfor i in range(m):\n    for j in range(n):\n        dfs(i, j, root)\nprint(\" \\".join(sorted(found)))""",
    "Q034": """n = int(input())\nactivities = [tuple(map(int, input().split())) for _ in range(n)]\nactivities.sort(key=lambda x: x[1])\ncount = 0\nend_time = -1\nfor start, finish in activities:\n    if start >= end_time:\n        count += 1\n        end_time = finish\nprint(count)""",
    "Q035": """import heapq\n\nsize = int(input())\nfreqs = []\nfor _ in range(size):\n    parts = input().split()\n    freqs.append(int(parts[-1]))\nheapq.heapify(freqs)\ncost = 0\nwhile len(freqs) > 1:\n    a = heapq.heappop(freqs)\n    b = heapq.heappop(freqs)\n    s = a + b\n    cost += s\n    heapq.heappush(freqs, s)\nprint(cost)""",
    "Q036": """n = int(input())\ncount = 0\nwhile n:\n    n &= n - 1\n    count += 1\nprint(count)""",
    "Q037": """n = int(input())\nnums = list(map(int, input().split()))\nresult = 0\nfor num in nums:\n    result ^= num\nprint(result)""",
    "Q038": """n = int(input())\nnums = list(map(int, input().split()))\ncurrent = max_sum = nums[0]\nfor num in nums[1:]:\n    current = max(num, current + num)\n    max_sum = max(max_sum, current)\nprint(max_sum)""",
    "Q039": """def merge_sort(arr):\n    if len(arr) <= 1:\n        return arr, 0\n    mid = len(arr) // 2\n    left, inv_left = merge_sort(arr[:mid])\n    right, inv_right = merge_sort(arr[mid:])\n    merged = []\n    i = j = 0\n    inv_count = inv_left + inv_right\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            merged.append(left[i])\n            i += 1\n        else:\n            merged.append(right[j])\n            j += 1\n            inv_count += len(left) - i\n    merged.extend(left[i:])\n    merged.extend(right[j:])\n    return merged, inv_count\n\n\n_ = int(input())\narr = list(map(int, input().split()))\n_, inversions = merge_sort(arr)\nprint(inversions)""",
    "Q040": """v, e = map(int, input().split())\nparent = list(range(v))\nrank = [0] * v\n\n\ndef find(x):\n    if parent[x] != x:\n        parent[x] = find(parent[x])\n    return parent[x]\n\n\ndef union(a, b):\n    ra, rb = find(a), find(b)\n    if ra == rb:\n        return False\n    if rank[ra] < rank[rb]:\n        parent[ra] = rb\n    elif rank[ra] > rank[rb]:\n        parent[rb] = ra\n    else:\n        parent[rb] = ra\n        rank[ra] += 1\n    return True\n\n\nhas_cycle = False\nfor _ in range(e):\n    u, w = map(int, input().split())\n    if not union(u, w):\n        has_cycle = True\nprint(\"true\" if has_cycle else \"false\")""",
    "Q041": """v, e = map(int, input().split())\nparent = list(range(v))\nrank = [0] * v\ncomponents = v\n\n\ndef find(x):\n    if parent[x] != x:\n        parent[x] = find(parent[x])\n    return parent[x]\n\n\ndef union(a, b):\n    nonlocal_components[0] -= 1 ???"""
}

base = pathlib.Path("student/server/logic")
for qid, code in codes.items():
    path = base / f"{qid}.json"
    data = json.loads(path.read_text())
    data["sampleLanguage"] = "python"
    data["sampleCode"] = code
    data["expectedCode"] = code
    path.write_text(json.dumps(data, indent=4))